/*
--*****************************************************
-- getTTFName-v0_10.ms
--
-- 08.11.01, swami*, a.k.a. "codeWarrior()", swami@cfl.rr.com
-- Written for MAX R4.20
-- (Does NOT run in R3.x)
--
--*****************************************************
--
--  ***************************************************
--  ***       FOR NON-COMMERCIAL USE ONLY!          ***
--  *** Contact the author for licensing agreement  ***
--  ***            or custom scripting              ***
--  ***       copyright 2001 SWAMANIMATIONS!        ***
--  ***************************************************
--
--*****************************************************
-- INSTALLATION:
--
-- Required Extensions  :
-- Required Scripts     :
-- Required Files       :ttfname.exe
-- Optional Files       :ttfname-v1_0.zip (source & exe)
--                      :TableDirectory&NameIDsExplained-010809-02.zip
--
--    - Put script anywhere.
--    - Put 'ttfname.exe' in max ..\scripts.
--*****************************************************
-- PURPOSE:
--    - To get common names of system ttf fonts.
--*****************************************************
-- USAGE:
--    - See end of script for examples...
--*****************************************************
-- COMMENTS:
--    - This is a WIP.
--    - There has been minimal testing. More is required...
--    - There is minimal error checking/handling.
--    - The script is NOT optimized.
--
--    - Dave Stewart <3dsmax@davestewart.co.uk> wrote:
--    - "
--    - Is it possible to get a list of installed fonts as an array to place in a dropdownlist box?
--    - "
--
--    - This script is a LIMITED solution.  Future versions will improve upon it...
--
--    - Overview of operation:
--        - ttf font names are gotten via a call to 'ttfname.exe' using 'DOSCommand'
--          (this leads to limitations which will be discussed, later...).
--          This executable runs in console mode in a DOSPrompt window.  The source code is in C++.
--        - The ttf font filenames are put into an array (via MXS).
--        - ttfname is called in a loop: once for each file.
--        - ttfname ATTEMPTS to read the Name Table data in the ttf.
--        - The results are output to the console by ttfname.
--        - This is piped to a temp file (c:\ttfnameTMP.txt) by MXS.
--        - According to the ttf spec., line 5 is the font common name.  This is the name which appears
--          in a max text object's dropdown list and the one required by the '.font' property in MXS.
--        - This line is put into a data structure which also contains the associated filename.
--        - The result is an array of data structures from which the names can be pulled (and sorted).
--          This has been automated via a call to 'getTTFNameStrs()'.
--        - Several usage examples are provided at the end of the script.
--
--    - Limitations:
--        - Each call to ttfname pops up a DOSPrompt window! That's a lot o windows considering the number
--          of fonts in the Windows fonts directory (150 on my system). It works, but it ain't pretty!
--        - ttfname does NOT always find a name table, or errors out in some way, resulting in 'undefined'
--          being assigned to the font name :( My test yielded 110 out of the 150 installed.
--
--    - Future Plans/Fixes...
--       1) The best fix is to realize the ttfname functionality in MXS. Binary read is possible in MXS,
--          and I have been able to identify some matching methods, so hopefully a conversion is possible.
--       2) Another fix is to modify the ttfname code to process an array of files (not just one at a time
--          as it currently does), and to output the results to a data file (instead of to the console).
--          This could then be read by MXS.
--       3) Get the font names from the Registry (don't know if I want to go there!)
--
--        - Solutions 1 and 2 require that I FULLY understand the ttfname code.
--          Time to dig in and learn some C++!...
--
--        - But in the meantime, here's a chunk of code that gets the font names into an array
--          (well, most of 'em)...
--*****************************************************
-- HISTORY:
-- (Legend: M => Major change; m => minor change; B => Bug fix; (i) => info.)
--    - v0.10 (08.11.01):
--        (i) 1st Beta version.
--*****************************************************
--
--             <<< S C R I P T   S T A R T S   H E R E >>> 
--
--
--------------------------
--<< F U N C T I O N S >>
--------------------------
--------------------------
-- FUNCTION (sortCaseInsensitive)
-- 
-- This function sorts an array of strings in ascending or descending alphabetical order while ignoring case.
-- Returns "undefined" if an error occurs.
-- By default, sort is asceneding.  For descending sort, pass asc:false.
-- Sort string value is case sensitive (e.g. "Z" is BEFORE "a"!).
-- Sort #name value is NOT case sensitive (go figure!).

fn sortCaseInsensitive theArray asc:true =
(
	try
	(
		theArray=for arg in theArray collect (arg as name)
		sort theArray
		
		if NOT asc then
		(
			local theArrayTMP=copy theArray #noMap
			local revIdx=theArray.count
			for i = 1 to theArray.count do
			(
				theArray[revIdx]=theArrayTMP[i] as string
				revIdx-=1
			)
			theArray
		)
		else
		(		
			theArray=for arg in theArray collect (arg as string)
		)
	)
	catch(theArray=undefined)
)
--------------------------
-- FUNCTION (getFontsFilenameArr)
--
-- This function gets all the font filenames from a directory.
-- This defaults to the Windows fonts directory.

fn getFontsFilenameArr fDir:(sysInfo.windowsDir+"\\Fonts\\") =
(
	setWaitCursor()
	
	sysFontsArr =getFiles (fDir+"*.ttf")
	sysFontsArr =sortCaseInsensitive sysFontsArr
	
	setArrowCursor()
	
	sysFontsArr
)
--------------------------
-- FUNCTION (getTTFName)
--
-- This function get the font common name for a SINGLE ttf file.
-- It returns a data structure containing the name and the associated filename.

fn getTTFName
		fDir:		(sysInfo.windowsDir+"\\Fonts\\")
		ttf:		"allegron"
		fFilename:	undefined
		dbug:		false
=
(
	setWaitCursor()
	
	-- Build filename.
	ff	=if fFilename!=undefined then fFilename else (fDir+ttf+".ttf")
	
	-- Call 'ttfname' and pipe results to a temp file.
	ttfnameTMP	="c:\\ttfnameTMP.txt"
	cmdStr		=(getDir #scripts)+"\\ttfname "+ff+" >"+ttfnameTMP
	DOSCommand cmdStr
	
	-- Open the temp file.
	df=openFile ttfnameTMP
	
	-- Get the font common name from the temp file.
	local fontName
	for i=1 to 5 where (NOT eof df) do
	(
		try
		(
			fontName=readLine df
		)
		catch exit
	)
	
	flush df
	close df

	setArrowCursor()
	
	-- Define and return the data structure.
	struct fontStruct (fName,cName)		-- fName=>filename; cName=>proper name.
	fontStruct fName:ff cName:fontName	-- Return a structure containing the filename AND the common name.
)
--------------------------
-- FUNCTION (getTTFNameStrs)
--
-- This function gets the font common names as an array of sorted strings for a given directory.

fn getTTFNameStrs
		fDir:		(sysInfo.windowsDir+"\\Fonts\\")
		fFilename:	undefined
		cntMax:		1000
		dbug:		false
=
(
	-- Get ALL the font filenames and common names.
	global gffAllArr, fontAllArr, fontArr
	
	gffAllArr	=getFontsFilenameArr()
	cnt			=0
	fontStruct	=for f in gffAllArr where (cnt+=1; cnt<=cntMax) collect getTTFName fFilename:f
	ttfNameStrs	=for f in fontStruct where (f.cName!=undefined) collect f.cName
	ttfNameStrs	=sortCaseInsensitive ttfNameStrs
)
--------------------------
--------------------------

-- USAGE:

-- Note: In general the results have been declared as global for inspection, but in practice they
--       should be declared as local whereever possible.

example=3	-- Set =0 to not run any example.
case example of
(
	1:-- Get ALL the font filenames into an array, and write results to Listener.
	(
		global gffAllArr, fontAllArr, fontArr
		
		gffAllArr	=getFontsFilenameArr()
		cnt			=0
		cntMax		=1000
		fontAllArr	=for f in gffAllArr where (cnt+=1; cnt<=cntMax) collect f
		
		-- Write ALL the font filenames and common names to the Listener.
		format "\nfontAllArr (cnt=%)\n" fontAllArr.count
		for f in fontAllArr do format "%\n" f
	)

	2:-- Get the first 5 font common names into an array, and write results to Listener.
	(
		global fontStrsArr=getTTFNameStrs cntMax:5
		
		format "\nFont Strings (%)\n" fontStrsArr.count
		for f in fontStrsArr do format "%\n" f
	)

	3:-- Get ALL the font common names into an array, and write results to Listener.
	(
		global fontStrsArr=getTTFNameStrs()
		
		format "\nFont Strings (%)\n" fontStrsArr.count
		for f in fontStrsArr do format "%\n" f
	)

	4:-- Get ALL the font filenames and common names, and write results to Listener.
	  -- This example can be used to troubleshoot which fonts files are not processed properly.
	(
		global gffAllArr
		
		gffAllArr	=getFontsFilenameArr()
		cnt			=0
		cntMax		=1000
		fontStruct	=for f in gffAllArr where (cnt+=1; cnt<=cntMax) collect getTTFName fFilename:f
		
		for f in fontStruct do format "%\n" f
	)
)

--------------------------------------------------------------------------------------------------------------------------------
-- Initialise fontList
--------------------------------------------------------------------------------------------------------------------------------
*/


fontList = fontStrsArr


--------------------------------------------------------------------------------------------------------------------------------
-- Initialise globals
--------------------------------------------------------------------------------------------------------------------------------

	-- initialise data variables
		global objectList = #()

	-- set up instanced controllers for text options
		global sizeCtrl = bezier_float ()
		global leadingCtrl = bezier_float ()
		global kerningCtrl = bezier_float ()
		
	-- initialise text formatting variables
		global tempShapeSteps = textOptions.shapeSteps.value
		global tempFont = textOptions.font.text
		global progressTotal = 0
		global progressCurrent = 0
	
	-- initialise others
		global d = 1

--------------------------------------------------------------------------------------------------------------------------------
-- Start main interface
--
--------------------------------------------------------------------------------------------------------------------------------
-- Define info, data & text options rollouts
--------------------------------------------------------------------------------------------------------------------------------

rollout info "Info & Instructions" width:176 height:672
(
		label info "A utility to quickly set-up still renders of multiple text objects.
		\rJust copy and paste your text to the list-box like so...
		\r    George Clooney\r    John Travolta\r    Anna Kournikova
		\r...then click \"Build Names\" and move the timeslider to see the results.
		\rApply whatever modifiers you want to the entire selection (this can be very slow), and render!
		\r* Note: At the moment, the only way to specify a font is to type the font name manually. The best method is to copy and paste the font name from an existing text object.
		" pos:[8,8] width:156 height:320
)

rollout data "Data" width:160 height:512
(
	edittext edt1 "" pos:[4,8] width:160 height:204 text:"Example Text:

Adele Love
Alex Hill
Alex Pearce
Alex Griffin
Alistair Nicol
Andrew Wilson
Andy Holmes
Annette Mehler
Becky Rowe
Ben Rassmussen
Ben Rowe
Ben Short
Brian Grindley
Bryn Bache"




)


rollout textPlacement "Text Placement" width:176 height:493
(
	GroupBox grpPositioning "Positioning" pos:[8,8] width:156 height:56
		checkbox twoLines "Split text to two lines" pos:[16,24] width:128 height:16 checked:true
		checkbox centre "Centre text vertically" pos:[16,40] width:128 height:16 checked:false


	GroupBox grpScaling "Scaling" pos:[8,72] width:156 height:112
		radiobuttons scaleMethod "" pos:[16,88] width:94 height:48 labels:#("None", "All same width", "All same height") default:1
		radioButtons scaleType "" pos:[16,144] width:116 height:32 labels:#("XForm modifier", "Scale transform")

	GroupBox grpDuration "Duration" pos:[8,192] width:156 height:44
		spinner frames "Show each for "  pos:[45,210] width:83 height:16 range:[1,1000,1] type:#integer 
		label frmLbl "frame" pos:[131,210] width:31 height:16
		


	--------------------------------------------------------------------------------------------------------------------------------
	-- handlers
	--------------------------------------------------------------------------------------------------------------------------------

	on frames changed val do
	(
		if frames.value == 1 then frmLbl.text = "frame"
		else frmLbl.text = "frames"
	)
)

rollout textOptions "Text Options" width:352 height:456
(
	GroupBox grpTypographic "Typographic" pos:[8,8] width:156 height:184

	radiobuttons pickFont "Pick font using:" pos:[16,24] width:148 height:30 labels:#("List-Box", "Type-In") columns:2
	dropdownList fontListBox "" pos:[16,64] width:144 height:21
	edittext fontTypeIn "" pos:[12,88] width:132 height:21 enabled:false
	button fontTypeInUpdt ">" pos:[144,88] width:14 height:21 toolTip:"Update font" enabled:false

	spinner size "Size" pos:[86,119] width:71 height:16 range:[0,1000,100] controller: sizeCtrl  
	spinner leading "Leading" pos:[73,143] width:84 height:16 range:[-1000,1000,0] controller: leadingCtrl 
	spinner kerning "Kerning" pos:[73,167] width:84 height:16 range:[-1000,1000,0] controller: kerningCtrl  

	GroupBox grpRendering "Rendering" pos:[8,200] width:156 height:40
	spinner shapeSteps "Shape steps" pos:[72,216] width:84 height:16 range:[0,10,1] type:#integer


	GroupBox vptUpdate "Font / Shape update" pos:[8,248] width:156 height:70
	button updateBtn "Update Now" pos:[16,266] width:66 height:16 enabled:false toolTip:"Update font and shape steps now"
	checkbutton interactiveBtn "Interactive" pos:[88,266] width:66 height:16 highlightColor:(color 0 255 0) toolTip:"Interactive viewport update from spinners" checked:true
	progressBar pb1 "ProgressBar" pos:[16,290] width:142 height:16
		


	--set up spinners & scene on open

	
	--------------------------------------------------------------------------------------------------------------------------------
	-- variables
	--------------------------------------------------------------------------------------------------------------------------------

	local font

	--------------------------------------------------------------------------------------------------------------------------------
	-- Font & Shape functions
	--------------------------------------------------------------------------------------------------------------------------------


	fn updatePB i progressTotal =
	(
		progressCurrent = progressCurrent + 1
		pb1.value = 100.0 * progressCurrent / progressTotal
		-- reset when progress bar is full
			if pb1.value == 100 then
			(
				pb1.value = 0
				progressTotal = 0
				progressCurrent = 0
			)
	)


	fn pickFontUpdt =
	(
		case pickFont.state of
		(
			1:(
				fontListBox.enabled=true
				fontTypeIn.enabled=false
				fontTypeInUpdt.enabled=false
			)
			2:(
				fontListBox.enabled=false
				fontTypeIn.enabled=true
				fontTypeInUpdt.enabled=true
			)
		)
			size.value = 100
	)

	fn updateFont =
	(
		if pickFont.state==1 then font=fontListBox.selected
			else font=fontTypeIn.text

		if objectList.count != 0 then
		(
			for i = 1 to objectList.count do
			(
				obj = execute ("$'" + objectList[i] + "'")
				obj.font = font
				updatePB i progressTotal
			)
			tempFont = font
		)
	)


	fn updateShapeSteps =
	(
		if objectList.count != 0 then
		(
			for i = 1 to objectList.count do
			(
				obj = execute ("$'" + objectList[i] + "'")
				obj.steps = shapeSteps.value
				updatePB i progressTotal
			)
			tempShapeSteps = textOptions.shapeSteps.value
		)
	)	
/**/

	--------------------------------------------------------------------------------------------------------------------------------
	-- Font & shape step handlers
	--------------------------------------------------------------------------------------------------------------------------------




/**/
		
		

	on textOptions open do
(
	sizeCtrl.value = 100
	for obj in geometry do delete obj
	for obj in shapes do delete obj
)


	on pickFont changed state do pickFontUpdt()


	on shapeSteps changed val do
(
	if textOptions.interactiveBtn.checked then
	(
		progressTotal = objectList.count
		updateShapeSteps()
	)
)
	on updateBtn pressed do
(
	progressTotal = 0
	
	-- Check if font needs updating (only if dropdown has changed from last time)
		if
		(
			(pickFont.state==1 AND textOptions.fontListBox.selected != tempFont) or	(pickFont.state==2 AND textOptions.fontTypeIn.text != tempFont)
		)
			then
			(
				progressTotal = progressTotal + objectList.count
				updateFontState = 1
				print "Updating Font"
			)
	
	-- Check if Shape Steps needs updating (only if spinner has changed from last time)
		if textOptions.shapeSteps.value != tempShapeSteps then
		(
			progressTotal = progressTotal + objectList.count
			updateShapeStepsState = 1
			print "Updating Steps"
		)
	
	-- call appropriate functions
	
		print ("progressTotal is " + progressTotal as String)
		if updateFontState == 1 then updateFont()
		if updateShapeStepsState == 1 then updateShapeSteps()
	
)
	on interactiveBtn changed state do
(
	if textOptions.updateBtn.enabled == false then textOptions.updateBtn.enabled = true
	else textOptions.updateBtn.enabled = false
)

	on textOptions open do pickFontUpdt()


)


--------------------------------------------------------------------------------------------------------------------------------
-- Define creation rollout
--------------------------------------------------------------------------------------------------------------------------------

rollout textObjects "Text Objects" width:160 height:56
(

	button createBtn "Create New" pos:[8,8] width:156 height:32 toolTip:"Build all the objects"
	button delLastBtn "Delete Last" pos:[8,48] width:156 height:16 toolTip:"Delete last created objects"
	button delAllBtn "Delete All" pos:[8,72] width:156 height:16 toolTip:"Delete all shapes / geometry" enabled:false


	--------------------------------------------------------------------------------------------------------------------------------
	-- Creation handlers
	--------------------------------------------------------------------------------------------------------------------------------
	on createBtn pressed do
	(
				-- deleteTextObj()
			-- set other globals
				spacing = 1000
				objectList = #()
				global d = textPlacement.frames.value

			-- updates font info
				textOptions.updateFont()


			-- Build names list
				names = data.edt1.text
				names = filterString names "\r\"\n"
				print names
	
	
			--sets the animation range
				if names.count == 0 then
				(
					print "No Data!"
				)
				else
				(
					animationRange = interval 0 ((names.count * d) + 1)
				)
	
	
			-- creates the objects & positions them
				for i = 1 to names.count do (
					

					-- build text
						obj = text size:textOptions.size.value transform:(matrix3 [1,0,0] [0,0,1] [0,-1,0] [0,0,0])
						obj.alignment = 2


					-- format text
						obj.font = textOptions.font as String
						obj.steps = textOptions.shapeSteps.value

						obj.size.controller = sizeCtrl
						obj.leading.controller = leadingCtrl
						obj.kerning.controller = kerningCtrl


					-- name new item
						if i < 10 then (obj.name = "Text0" + i as String + " : " + names[i])
						else (obj.name = "Text" + i as String + " : " + names[i])
					

					--put item name in array for deleting
						append objectList obj.name



					-- colour new item
						objClr = [0,0,0] as Color
						objClr.b = ((i as Float / names.count) * 255)
						obj.wirecolor = objClr



					-- put in carriage returns if requested
						if textPlacement.twoLines.checked then
						(
							displayText = names[i]
							spaceIndex = findString displayText " " -- find any spaces
							if spaceIndex != undefined then
							(
								obj.text = replace displayText spaceIndex 1 "\r"
							)
							else
							(
								obj.text = displayText
							)
						)
						else
						(
							obj.text  = names[i]
						)




					-- Set up scaling
						targetWidth = 400
						targetHeight = 300
						
						fn scaleText obj targetScale =
					(
							case textPlacement.scaleType.state of
						(
							1:(
								addModifier obj (XForm()) ui:on
								obj.modifiers[#XForm].gizmo.scale *= [targetScale ,targetScale ,targetScale ]
								modPanel.setCurrentObject obj.modifiers[#XForm]
								subobjectLevel = 0
							)
							2: (
								obj.scale = [targetScale ,targetScale ,targetScale ]
							)	
						)
					)
						
						case textPlacement.scaleMethod.state of
						(
							1:
							(
								-- do nothing
							)
							2:
							 (
								span = obj.max.x - obj.min.x
								targetScale = targetHeight / span
								scaleText obj targetScale
							)
								
							3:
							 (
								span = obj.max.z - obj.min.z
								targetScale = targetHeight / span
								scaleText obj targetScale
							)
						) 
		

					-- set up objects to move
						obj.pos.controller = Position_XYZ ()

						c = bezier_float ()
						obj.pos.controller.Z_Position.controller = c

						key1 = addNewKey c ( ((d*(i-1))) as Time )
						key2 = addNewKey c ( ((d*(i-1)) + 1) as Time )
						key3 = addNewKey c ( ((d*(i-1)) +d) as Time )
						key4 = addNewKey c ( ((d*(i-1)) +d +1) as Time )
						

					-- convert all the keys to type: #step / #linear
						key1.inTangentType = #linear
						key1.outTangentType = #linear
						key2.inTangentType = #linear
						key2.outTangentType = #linear
						key3.inTangentType = #linear
						key3.outTangentType = #linear
						key4.inTangentType = #linear
						key4.outTangentType = #linear
						
					
					-- Centre the object if requested
						if textPlacement.centre.checked then (
							obj.pivot.z = (obj.max.z - obj.min.z) / 2 + obj.min.z
					)

						key1.value = spacing
						key2.value = 0
						key3.value = 0
						key4.value = -spacing
	
					-- Update progress bar
						textOptions.updatePB i names.count


			)
				sliderTime = 1
				print "Printing Object List..."
				print objectList
)


	fn deleteTextObj =
	(
		for i = 1 to objectList.count do
		(
				obj = execute ("$'" + objectList[i] + "'")
				if obj != undefined then delete obj

			-- Update progress bar
				textOptions.updatePB i objectList.count
		)
			objectList = #()
	)

	on delLastBtn pressed do
	(
		deleteTextObj()
	)


	fn deleteAllTextObj =
	(
		for obj in objects do
			if (substring obj.name 1 4) == "Text" do
				delete obj
	)

	on delAllBtn pressed do deleteAllTextObj()


)



--------------------------------------------------------------------------------------------------------------------------------
-- Define tools & credits rollouts
--------------------------------------------------------------------------------------------------------------------------------


rollout tools "Tools" width:160 height:512
(
	button camBtn "Create Camera" pos:[8,8] width:74 height:16 toolTip:"Place a camera in the scene"
	button listBtn "List Objects" pos:[90,8] width:74 height:16 toolTip:"Print a list of all the objects to the Listener"

	--------------------------------------------------------------------------------------------------------------------------------
	-- Tools handlers
	--------------------------------------------------------------------------------------------------------------------------------

	on camBtn pressed do
	(
		if $Camera_SimpleCredits == undefined then
		(
			camSC = Freecamera fov:45 targetDistance:160 nearclip:1 farclip:1000 nearrange:0 farrange:1000 mpassEnabled:off mpassRenderPerPass:off transform:(matrix3 [1,0,0] [0,0,1] [0,-1,0] [0,-700,0])
			camSC.name = "Camera SimpleCredits"
			camSC.ignoreExtents = on
		)
		else
		(
			print "Camera already exists"
		)
			max vpt camera
	)


	on listBtn pressed do
	(
		for i = 1 to objectList.count do (print objectList[i])
	)
		
)



rollout credits "Credits" width:160 height:40
(
	button webBtn "www.davestewart.co.uk" width:156 height:16
	on webBtn pressed do
	(
		ShellLaunch "iexplore.exe" "http://www.davestewart.co.uk"
	 )
)

--------------------------------------------------------------------------------------------------------------------------------
-- Final setup
--------------------------------------------------------------------------------------------------------------------------------

-- create the Floater window and add the rollouts
	if SCrof != undefined do
	(
		closerolloutfloater SCrof
	)		

	SCrof=newrolloutfloater "Simple Credits" 200 200

-- add the rollouts
	addrollout info SCrof
	addrollout data SCrof
	addrollout textPlacement SCrof
	addrollout textOptions SCrof
	addrollout textObjects SCrof
	addrollout tools SCrof
	addrollout credits SCrof
	
-- position & setup the floater
	SCrof.size=[200,843]
	SCrof.pos=[43,92]
	info.open=false
	tools.open=false
	credits.open=false



